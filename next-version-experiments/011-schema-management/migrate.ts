// src/scripts/migrate.ts
import { Command, FileSystem, Path } from '@effect/platform'
import { BunContext, BunRuntime } from '@effect/platform-bun'
import {
	Console,
	Effect,
	Array as EffectArray,
	String as EffectString,
	pipe,
	Schema,
} from 'effect'

const ATLAS_DIR = 'src/db/migrations-sql'
const EFFECT_DIR = 'src/db/migrations-effect'
const ATLAS_ENV = 'local'

// --- Schema for CLI args ---

const MigrationNameArg = Schema.String.pipe(
	Schema.minLength(1),
	Schema.pattern(/^[a-z][a-z0-9_]*$/),
	Schema.annotations({
		message: () =>
			'Migration name must be lowercase alphanumeric with underscores',
	}),
)

// --- Helpers ---

const escapeForTemplateLiteral = (sql: string): string =>
	sql.replace(/\\/g, '\\\\').replace(/`/g, '\\`').replace(/\$\{/g, '\\${')

const parseSqlStatements = (content: string): Array<string> =>
	content
		.split(';')
		.map((s) => s.trim())
		.filter((s) => s.length > 0)

const generateEffectMigration = (
	statements: Array<string>,
	baseName: string,
): string => {
	const escaped = statements.map(escapeForTemplateLiteral)
	return `// This file was autogenerated by \`migrate.ts\` based on \`src/db/migrations-sql/${baseName}.sql\`
import { Effect } from "effect";
import { SqlClient } from "@effect/sql";

export default Effect.gen(function* () {
  const sql = yield* SqlClient.SqlClient;
${escaped.map((stmt) => `  yield* sql\`${stmt}\`;`).join('\n\n')}
});
`
}

const generateIndexFile = (migrationNames: Array<string>): string => {
	const imports = migrationNames
		.map((name) => {
			const safeName = name.replace(/\W/g, '_')
			return `import * as _${safeName} from "./${name}";`
		})
		.join('\n')

	const exports = migrationNames
		.map((name) => {
			const safeName = name.replace(/\W/g, '_')
			return `  "${name}": _${safeName}.default,`
		})
		.join('\n')

	return `// Auto-generated by migrate.ts - do not edit
${imports}

export const migrations = {
${exports}
} as const;
`
}

// --- Main program ---

const formatSchemaSQL = Effect.gen(function* () {
	yield* Effect.log('Formatting schema file')

	const command = Command.make('sql-formatter', '--fix', 'src/db/schema.sql')

	const result = yield* pipe(
		command,
		Command.stdout('inherit'),
		Command.stderr('inherit'),
		Command.exitCode,
	)

	if (result !== 0) {
		return yield* Effect.fail(
			new Error(`Formatting exited with code ${result}`),
		)
	}
})

const runAtlasDiff = (migrationName: string) =>
	Effect.gen(function* () {
		yield* Effect.log(`Running atlas migrate diff: ${migrationName}`)

		const command = Command.make(
			'npx',
			'@ariga/atlas',
			'migrate',
			'diff',
			migrationName,
			'--env',
			ATLAS_ENV,
		)

		const result = yield* pipe(
			command,
			Command.stdout('inherit'),
			Command.stderr('inherit'),
			Command.exitCode,
		)

		if (result !== 0) {
			return yield* Effect.fail(new Error(`Atlas exited with code ${result}`))
		}

		yield* Effect.log('Atlas migration generated successfully')
	})

const convertMigrations = Effect.gen(function* () {
	const fs = yield* FileSystem.FileSystem
	const path = yield* Path.Path

	const atlasPath = path.resolve(ATLAS_DIR)
	const effectPath = path.resolve(EFFECT_DIR)

	yield* fs.makeDirectory(effectPath, { recursive: true })

	const allFiles = yield* fs.readDirectory(atlasPath)
	const sqlFiles = pipe(
		allFiles,
		EffectArray.filter((f) => f.endsWith('.sql')),
		EffectArray.sort(EffectString.Order),
	)

	if (EffectArray.isEmptyArray(sqlFiles)) {
		yield* Effect.log('No SQL migration files found')
		return
	}

	const migrationNames: Array<string> = []

	for (const file of sqlFiles) {
		const content = yield* fs.readFileString(path.join(atlasPath, file))
		const baseName = file.replace('.sql', '')
		const statements = parseSqlStatements(content)

		if (statements.length === 0) {
			yield* Effect.log(`⚠ Skipping ${file} (no statements)`)
			continue
		}

		const effectCode = generateEffectMigration(statements, baseName)
		const outputPath = path.join(effectPath, `${baseName}.ts`)

		yield* fs.writeFileString(outputPath, effectCode)
		yield* Effect.log(
			`✓ ${file} → ${baseName}.ts (${statements.length} statements)`,
		)

		migrationNames.push(baseName)
	}

	const indexContent = generateIndexFile(migrationNames)
	yield* fs.writeFileString(path.join(effectPath, 'index.ts'), indexContent)
	yield* Effect.log(
		`✓ Generated index.ts with ${migrationNames.length} migrations`,
	)
})

const program = Effect.gen(function* () {
	const args = yield* Effect.sync(() => process.argv.slice(2))

	if (args.length === 0) {
		yield* Console.error('Usage: bun run migrate.ts <migration_name>')
		yield* Console.error('Example: bun run migrate.ts add_users_table')
		return yield* Effect.fail(new Error('Missing migration name'))
	}

	const migrationName = yield* Schema.decodeUnknown(MigrationNameArg)(
		args[0],
	).pipe(
		Effect.mapError(
			() =>
				new Error(
					'Invalid migration name. Use lowercase alphanumeric with underscores.',
				),
		),
	)

	yield* formatSchemaSQL
	yield* runAtlasDiff(migrationName)
	yield* convertMigrations

	yield* Effect.log('\n✅ Migration complete!')
})

pipe(program, Effect.provide(BunContext.layer), BunRuntime.runMain)
